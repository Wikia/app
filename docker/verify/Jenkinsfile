// todo use it when border settings for handling `-k8s` suffix will be prepared
// def sandbox = params.sandbox_name.endsWith("-k8s") ?  params.sandbox_name : params.sandbox_name + '-k8s';
def datacenter = params.datacenter
println("Current release branch for deployment: '${params.release_branch}'")
if (params.release_branch == ''){
     currentBuild.result = 'ABORTED'
     error('Please set release_branch param')
}
println("Current release branch: '${params.release_branch}'")
def escapedReleaseBranch = params.release_branch.replace('-', "\\-")



def kubectlImage = env["K8S_DEPLOYER_IMAGE"]
def nginxImage = "artifactory.wikia-inc.com/sus/mediawiki-sandbox-nginx"
def mediawikiImage = "artifactory.wikia-inc.com/sus/mediawiki-php"

def rolloutStatus = 1

def render(String template, java.util.LinkedHashMap binding) {
  def engine = new groovy.text.SimpleTemplateEngine()

  return engine.createTemplate(template).make(binding).toString()
}

// examples of what a tag, version and branch mean in the code below
// tag: release-751.001
// version: 751.001
// branch: release-751

def get_latest_version() {
  // eg. 757.001
  def latestVersion = sh(
    script: "git describe --abbrev=0 --tags --match '${params.release_branch}*'",
    returnStdout: true
  )
  .trim()
  .replace('release-', '')

  if (latestVersion) {
    return latestVersion
  } else {
    return '000.000'
  }
}

// 770.001 -> 771.001
// 600.009 -> 601.001
// none -> 1.001
def bump_major() {
  def currentVersion = get_latest_version()

  def nextMajorVersion = currentVersion.tokenize('.')[0].toInteger() + 1

  return nextMajorVersion + ".001"
}

// 770.001 -> 770.002
// none -> 000.001
def bump_minor() {
  def currentVersion = get_latest_version()

  def currentVersionTokens = currentVersion.tokenize('.')
  def currentMajorVersion = currentVersionTokens[0]
  def nextMinorVersion = (currentVersionTokens[1].toInteger() + 1).toString().padLeft(3, '0')

  return currentMajorVersion + "." + nextMinorVersion
}

def createReleaseBranch(String releaseBranch) {
  sh(script: "git checkout ${releaseBranch} || git checkout -b ${releaseBranch}")
  sh(script: "git push --set-upstream origin ${releaseBranch}")
}

// If new release - create a tag e.g. release-230.001
// if hotfix - create new tag for current relaese branch if any commit were made to it
def createTag(String nextTag) {
  // e.g. 219.001
  def currentVersion = get_latest_version()
  println("Current version: ${currentVersion}")

  def hasUnreleasedCommits = true
  if (params.source == 'hotfix') {
    hasUnreleasedCommits = sh(
        script: "git log HEAD...release-${currentVersion}",
        returnStdout: true
      )
      .trim()
  }

  if (hasUnreleasedCommits) {
    doesTagExist = sh(script: "git tag --list ${nextTag}", returnStdout: true).trim()

    if (doesTagExist) {
      println("Tag already exists: ${nextTag}")
    } else {
      println("Creating tag: ${nextTag}")
      sshagent(['bd3cf712-39a7-4b16-979e-ff86208ab2ea']) {
        if (!params.dry_run) {
          sh(script: "git tag --annotate --message ${nextTag} ${nextTag}")
          sh(script: "git push origin ${nextTag}")
        } else {
          println("Dry run: git tag --annotate --message ${nextTag} ${nextTag}")
          println("Dry run: git push origin ${nextTag}")
        }
      }
    }
    return nextTag
  } else {
    //e.g. release-219.001
    def latestTagOnCurrentRelease = 'release-' + currentVersion
    // no new commits
    println("No new commits - redeploy: ${latestTagOnCurrentRelease}")

    return latestTagOnCurrentRelease
  }
}

def notifyBuild(String buildStatus = 'STARTED', String appTag, String configTag, String buildUser) {
  // build status of null means successful
  buildStatus =  buildStatus ?: 'SUCCESSFUL'

  // Default values
  def colorName = 'RED'
  def colorCode = '#FF0000'
  def summary = "K8S (mirror deploy): *${buildStatus}*: <${env.BUILD_URL}|${env.JOB_NAME}. Build #${env.BUILD_NUMBER}> by ${buildUser}"

  if (appTag && configTag) {
    summary = summary + " - app tag <https://github.com/Wikia/app/releases/tag/${appTag}|${appTag}> and config tag <https://github.com/Wikia/config/releases/tag/${configTag}|${configTag}>"
  }

  // Override default values based on build status
  if (buildStatus == 'STARTED') {
    color = 'BLUE'
    colorCode = '#70CADB'
  } else if (buildStatus == 'SUCCESSFUL') {
    color = 'GREEN'
    colorCode = '#36A64F'
  } else {
    summary = summary + " <!here>"
  }

  // Send notifications
  if (!params.dry_run) {
    slackSend (channel: '#release-progress', color: colorCode, failOnError: true, message: summary)
  }

  println("Slack message: ${summary}")
}

node("docker-daemon") {
  def buildUser = "Anonymous"
  def appHash
  def configHash
  def imageTag

  def currentAppTag

  def lastAppReleaseBranch

  def nextAppReleaseVersion
  def nextAppReleaseTag
  def nextAppReleaseBranch

  def lastConfigReleaseBranch

  def nextConfigReleaseVersion
  def nextConfigReleaseTag
  def nextConfigReleaseBranch

  wrap([$class: 'BuildUser']) {
    try {
      buildUser = "${BUILD_USER}"
    } catch (MissingPropertyException ex) {
      buildUser = "Jenkins"
    }
  }

  stage('Slack notify start') {
    notifyBuild('STARTED', '', '', buildUser)
  }

  try {
    stage("Clone repositories") {
      parallel (
        "app": {
          dir("app") {
            git url: "git@github.com:Wikia/app.git",
              branch: 'dev',
              credentialsId: "bd3cf712-39a7-4b16-979e-ff86208ab2ea"
          }
        },
        "config": {
          dir("config") {
            git url: "git@github.com:Wikia/config.git",
              branch: 'dev',
              credentialsId: "bd3cf712-39a7-4b16-979e-ff86208ab2ea"
          }
        }
      )
    }

    stage("Checkout to last release branch") {
      parallel (
        "app": {
          if (params.source == 'latest' || params.source == 'hotfix') {
            sshagent(['bd3cf712-39a7-4b16-979e-ff86208ab2ea']) {
              dir("app") {
                //e.g. release-220.001
                def lastAppReleaseTag = "release-" + get_latest_version()

                //e.g. release-220
                lastAppReleaseBranch = lastAppReleaseTag.tokenize('.')[0]

                println("Checking out to last release branch: ${lastAppReleaseBranch}")
                sh(script: "git checkout ${lastAppReleaseBranch} || git checkout -b ${lastAppReleaseBranch}")
                sh(script: "git pull -r")
              }
            }
          }
        },
        "config": {
          if (params.source == 'latest' || params.source == 'hotfix') {
            sshagent(['bd3cf712-39a7-4b16-979e-ff86208ab2ea']) {
              dir("config") {
                //e.g. release-220.001
                def lastConfigReleaseTag = "release-" + get_latest_version()

                //e.g. release-220
                lastConfigReleaseBranch = lastConfigReleaseTag.tokenize('.')[0]

                println("Checking out to last release branch: ${lastConfigReleaseBranch}")
                sh(script: "git checkout ${lastConfigReleaseBranch} || git checkout -b ${lastConfigReleaseBranch}")
                sh(script: "git pull -r")
              }
            }
          }
        }
      )
    }

    stage("Calculate next release branch and version") {
      parallel (
        "app": {
          dir("app") {
            if (params.source == 'latest') {
              nextAppReleaseVersion = get_latest_version()
            } else if (params.source == 'hotfix') {
              nextAppReleaseVersion = bump_minor()
            } else {
              nextAppReleaseVersion = bump_major()
            }

            //e.g. release-220.001
            nextAppReleaseTag = "release-" + nextAppReleaseVersion
            //e.g. release-220
            nextAppReleaseBranch = nextAppReleaseTag.tokenize('.')[0]

            println("Version: ${nextAppReleaseVersion}")
            println("Tag: ${nextAppReleaseTag}")
            println("Branch: ${nextAppReleaseBranch}")
          }
        },
        "config": {
          dir("config") {
            if (params.source == 'latest') {
              nextConfigReleaseVersion = get_latest_version()
            } else if (params.source == 'hotfix') {
              nextConfigReleaseVersion = bump_minor()
            } else {
              nextConfigReleaseVersion = bump_major()
            }

            nextConfigReleaseTag = "release-" + nextConfigReleaseVersion
            nextConfigReleaseBranch = nextConfigReleaseTag.tokenize('.')[0]

            println("Version: ${nextConfigReleaseVersion}")
            println("Tag: ${nextConfigReleaseTag}")
            println("Branch: ${nextConfigReleaseBranch}")
          }
        }
      )
    }

    stage("Fetch version") {
      def deploymentInfo

      withDockerContainer(kubectlImage) {
        deploymentInfo = sh(
          script: "kubectl --context kube-${datacenter}-prod -n prod get deployments -l app=mediawiki-verify -o jsonpath='{.items[0].spec.template.metadata.labels}'",
          returnStdout: true
        )
      }

      currentAppTag = sh(
        script: "echo \"${deploymentInfo}\" | sed 's/.*app_version:\\([^] ]*\\).*/\\1/'",
        returnStdout: true
      )
      def currentConfigTag = sh(
        script: "echo \"${deploymentInfo}\" | sed 's/.*config_version:\\([^] ]*\\).*/\\1/'",
        returnStdout: true
      )
    }

    sshagent(['bd3cf712-39a7-4b16-979e-ff86208ab2ea']) {
      stage("Create new release branches") {
        parallel (
          "app": {
            dir("app") {
              if (params.source == 'latest') {
                println("Source: latest; checkout tag: ${nextAppReleaseTag}")
                createReleaseBranch(nextAppReleaseTag)
              } else {
                createReleaseBranch(nextAppReleaseBranch)
              }
            }
          },
          "config": {
            dir("config") {
              if (params.source == 'latest') {
                println("Source: latest; checkout tag: ${nextConfigReleaseTag}")
                createReleaseBranch(nextConfigReleaseTag)
              } else {
                createReleaseBranch(nextConfigReleaseBranch)
              }
            }
          }
        )
      }

      stage("Create release tags") {
        parallel (
          "app": {
            dir("app") {
              if (params.source == 'latest') {
                println("Source: latest; skip creating a tag")
              } else {
                nextAppReleaseTag = createTag(nextAppReleaseTag)
              }
            }
          },
          "config": {
            dir("config") {
              if (params.source == 'latest') {
                println("Source: latest; skip creating a tag")
              } else {
                nextConfigReleaseTag = createTag(nextConfigReleaseTag)
              }
            }
          }
        )
      }
    }

    stage("Calculate docker image tag") {
      parallel (
        "app": {
          dir("app") {
            appHash = sh(script: "git describe --abbrev=0 --tags --match '${escapedReleaseBranch}*'", returnStdout: true).trim()
            if (!appHash) {
                throw new Exception("No tag found for this app branch")
            }

            println("Wikia/app commit: $appHash")
          }
        },
        "config": {
          dir("config") {
            configHash = sh(script: "git describe --abbrev=0 --tags --match '${escapedReleaseBranch}*'", returnStdout: true).trim()
            if (!configHash) {
                throw new Exception("No tag found for this config branch")
            }

            println("Wikia/config commit: $configHash")
          }
        }
      )

      imageTag = appHash + "_" + configHash

      println("Image tag: $imageTag")
    }

    stage("Bump cachebuster and version") {
      parallel (
        "app": {
          dir("app") {
            def cacheBuster = new Date().getTime()

            sh('echo "<?php\n\\\$wgStyleVersion = ' + cacheBuster + ';" > wgStyleVersion.php')
            sh('echo "' + nextAppReleaseTag + '@' + appHash + '" > wikia.version.txt')
          }
        },
        "config": {
          dir("config") {
            sh('echo "' + nextConfigReleaseTag + '@' + configHash + '" > wikia.version.txt')
          }
        }
      )
    }

    parallel (
      "php": {
        stage("Build and push php image") {
          dir("app") {
            def imageExists = false
            def status = sh(script: """
              curl -u ${env.JENKINS_ARTIFACTORY_USERNAME}:${env.JENKINS_ARTIFACTORY_PASSWORD} \
              -w "%{http_code}" -s -I -o /dev/null \
              -XGET "https://artifactory.wikia-inc.com/artifactory/api/storage/dockerv2-local/sus/mediawiki-php/${imageTag}"
            """, returnStdout: true).trim()

            if (status == "200") {
              imageExists = true
            }

            if (!imageExists) {
              if (params.dry_run) {
                println("Dry run: docker build .. -f docker/base/Dockerfile-php -t $mediawikiImage:$imageTag")
              } else {
                // SUS-5284 - make the image a bit smaller
                sh("cp docker/.dockerignore ..")
                sh("docker build .. -f docker/base/Dockerfile-php -t $mediawikiImage:$imageTag")
                sh("docker push $mediawikiImage:$imageTag")
              }

            } else {
              println("Php image tag ($imageTag) already exists")
            }
          }
        }
      },
      "nginx": {
        stage("Build and push nginx image") {
          dir("app") {
            def imageExists = false
            def status = sh(script: """
              curl -u ${env.JENKINS_ARTIFACTORY_USERNAME}:${env.JENKINS_ARTIFACTORY_PASSWORD} \
              -w "%{http_code}" -s -I -o /dev/null \
              -XGET "https://artifactory.wikia-inc.com/artifactory/api/storage/dockerv2-local/sus/mediawiki-sandbox-nginx/${imageTag}"
            """, returnStdout: true).trim()

            if (status == "200") {
              imageExists = true
            }

            if (!imageExists) {

              if (params.dry_run) {
                println("Dry run: docker build  . -f docker/sandbox/Dockerfile-nginx -t $nginxImage:$imageTag")
              } else {
                // SUS-5284 - make the image a bit smaller
                sh("cp docker/.dockerignore ..")
                sh("docker build  . -f docker/sandbox/Dockerfile-nginx -t $nginxImage:$imageTag")
                sh("docker push $nginxImage:$imageTag")
              }
            } else {
              println("Nginx image tag ($imageTag) already exists")
            }
          }
        }
      }
    )

    stage("Apply new k8s descriptor") {
      dir("app") {
        // verify is essentially the same env as a sandbox
        def template = sh(script: 'cat docker/sandbox/sandbox.template.yaml', returnStdout: true)
        def k8s = render(template, [
          'MEDIAWIKI_IMAGE': mediawikiImage,
          'IMAGE_TAG': imageTag,
          'SANDBOX_NAME': 'verify',
          'SANDBOX_ENVIRONMENT': 'verify',
          'SANDBOX_DATACENTER': datacenter,
          'APP_VERSION': nextAppReleaseTag,
          'CONFIG_VERSION': nextConfigReleaseTag,
          'REPLICAS': 4,
          'MAX_REPLICAS': 10
        ])

        sh("""cat > docker/sandbox/k8s.yaml <<EOL
${k8s}
EOL""")

        sh("cat docker/sandbox/k8s.yaml")
      }

      if (!params.dry_run) {
        withDockerContainer(kubectlImage) {
          sh "kubectl --context kube-${datacenter}-prod -n prod apply -f app/docker/sandbox/k8s.yaml"
          rolloutStatus = sh(returnStatus: true, script: "kubectl --context kube-${datacenter}-prod -n prod rollout status deployment/mediawiki-verify")
        }
      } else {
        println("Dry run: kubectl --context kube-${datacenter}-prod -n prod apply -f app/docker/sandbox/k8s.yaml")
        rolloutStatus = 0
      }

    }

  } catch (e) {
    // If there was an exception thrown, the build failed
    currentBuild.result = "FAILED"
    throw e
  } finally {
    stage('Set and report job status') {
      if (rolloutStatus != 0) {
        currentBuild.result = "UNSTABLE"
      }

      notifyBuild(currentBuild.result, nextAppReleaseTag, nextConfigReleaseTag, buildUser)
    }
  }
}
