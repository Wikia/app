<?php
abstract class WikiaParserTagController extends WikiaController {

	/**
	 * Simple counter used in generating markers' ids
	 * @var int
	 */
	private $count = 1;

	/**
	 * An array with markers ids and real output for our tags
	 * @var array
	 */
	protected $markers = [];

	/**
	 * White list of attributes to be checked and validated
	 *
	 * @var array
	 */
	protected $tagAttributes = [];

	/**
	 * @desc Hook function registered in $wgHooks['ParserFirstCallInit'][] which should always return true
	 *
	 * @param Parser $parser
	 * @return Boolean true
	 */
	public static function onParserFirstCallInit( Parser $parser ) {
		global $wgHooks;

		$tag = new static();
		$parser->setHook( $tag->getTagName(), [ $tag, 'renderTag' ] );
		$wgHooks['ParserAfterTidy'][] = [ $tag, 'onParserAfterTidy' ];
		$wgHooks['ArticleAsJsonBeforeEncode'][] = [ $tag, 'onArticleAsJsonBeforeEncode' ];

		return true;
	}

	abstract public function getTagName();

	abstract protected function getErrorOutput( $errorMessages );

	abstract protected function getSuccessOutput( $args );

	/**
	 * @desc Factory method to create validators for params
	 * if should return WikiaValidatorAlwaysTrue if validator can't be created or won't be used
	 *
	 * @param String $paramName
	 * @return WikiaValidator
	 */
	abstract protected function buildParamValidator( $paramName );

	protected function registerResourceLoaderModules( Parser $parser ) {
	}

	public final function renderTag( $input, array $args, Parser $parser, PPFrame $frame ) {
		$this->registerResourceLoaderModules( $parser );
		$markerId = $this->generateMarkerId( $parser );
		$errorMessages = $this->validateAttributes( $args );

		if( !empty( $errorMessages ) ) {
			$this->addMarkerOutput( $markerId, $this->getErrorOutput( $errorMessages ));
		} else {
			$this->addMarkerOutput( $markerId, $this->getSuccessOutput( $args ) );
		}

		return $markerId;
	}

	public final function onParserAfterTidy( Parser $parser, &$text ) {
		if ( !$this->wg->ArticleAsJson ) {
			$text = $this->replaceMarkers( $text );
		}
		return true;
	}

	public final function onArticleAsJsonBeforeEncode( &$text ) {
		$text = $this->replaceMarkers( $text );
		return true;
	}

	public final function replaceMarkers( $text ) {
		return strtr( $text, $this->getMarkers() );
	}

	/**
	 * @desc Checks if all parameters from tag are valid
	 *
	 * @param Array $attributes attributes passed in tag
	 *
	 * @return Array $errorMessages
	 */
	public function validateAttributes( $attributes ) {
		$errorMessages = [];

		foreach( $this->tagAttributes as $attrName ) {
			$validator = $this->buildParamValidator( $attrName );
			$value = array_key_exists( $attrName, $attributes ) ? $attributes[$attrName] : false;

			if( !$validator->isValid( $value ) ) {
				$error = $validator->getError();

				if ( !is_null($error) ) {
					$errorMessage = $error->getMsg();
					$errorMessages[] = (object) [
						'attribute' => $attrName,
						'message' => $errorMessage
					];
				} else {
					$errorMessages[] = (object) [
						'attribute' => $attrName,
						'message' => 'undefined'
					];
				}
			}
		}

		return $errorMessages;
	}

	/**
	 * @desc Generates unique strings which will be placed instead of tags
	 *
	 * @param Parser $parser
	 * @return string
	 */
	protected function generateMarkerId( Parser $parser ) {
		$wikiaParserMarkerSufix = '-WIKIA-PARSER-MARKER-' . $this->getTagName() . ' - '. $this->count;
		$this->count++;
		return $parser->uniqPrefix() . $wikiaParserMarkerSufix . "-\x7f";
	}

	/**
	 * @desc Adds output which will replaced unique strings which replaced tags in the article
	 *
	 * @param String $markerId id generated by generateMarkerId()
	 * @param $output
	 */
	protected function addMarkerOutput( $markerId, $output ) {
		if( !empty( $this->wg->ArticleAsJson ) && $output instanceof WikiaResponse ) {
			$this->markers[$markerId] = $output->toString();
		} else {
			$this->markers[$markerId] = $output;
		}
	}

	public function getMarkers() {
		return $this->markers;
	}
}
