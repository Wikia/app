<?php
abstract class WikiaParserTagController extends WikiaController {

	/**
	 * Simple counter used in generating markers' ids
	 * @var int
	 */
	private $count = 1;

	/**
	 * An array with markers ids and real output for our tags
	 * @var array
	 */
	protected $markers = [];

	/**
	 * White list of attributes to be checked and validated
	 *
	 * @var array
	 */
	protected $tagAttributes = [];

	/**
	 * @desc Hook function registered in $wgHooks['ParserFirstCallInit'][] which should always return true
	 *
	 * @param Parser $parser
	 * @return Boolean true
	 */
	public static function onParserFirstCallInit( Parser $parser ) {
		global $wgHooks;

		$tag = new static();
		$parser->setHook( $tag->getTagName(), [ $tag, 'renderTag' ] );
		$wgHooks['ParserAfterTidy'][] = [ $tag, 'onParserAfterTidy' ];

		return true;
	}

	abstract public function getTagName();

	abstract protected function getErrorOutput( $errorMessages );

	abstract protected function getSuccessOutput( $args );

	/**
	 * @desc Factory method to create validators for params
	 * if should return WikiaValidatorAlwaysTrue if validator can't be created or won't be used
	 *
	 * @param String $paramName
	 * @return WikiaValidator
	 */
	abstract protected function buildParamValidator( $paramName );

	protected function registerResourceLoaderModules( Parser $parser ) {
	}

	public final function renderTag( $input, array $args, Parser $parser, PPFrame $frame ) {
		$this->registerResourceLoaderModules( $parser );
		$markerId = $this->generateMarkerId( $parser );
		$errorMessages = $this->validateAttributes( $args );

		if( !empty( $errorMessages ) ) {
			$this->addMarkerOutput( $markerId, $this->getErrorOutput( $errorMessages ));
		} else {
			$this->addMarkerOutput( $markerId, $this->getSuccessOutput( $args ) );
		}

		return $markerId;
	}

	public final function onParserAfterTidy( Parser &$parser, &$text ) {
		$text = strtr( $text, $this->getMarkers() );
		return true;
	}

	/**
	 * @desc Checks if all parameters from tag are valid
	 *
	 * @param Array $attributes attributes passed in tag
	 *
	 * @return Array $errorMessages
	 */
	public function validateAttributes( $attributes ) {
		$errorMessages = [];

		foreach( $this->tagAttributes as $attrName ) {
			$validator = $this->buildParamValidator( $attrName );

			if( !$validator->isValid( $attributes[$attrName] ) ) {
				$error = $validator->getError();

				if ( !is_null($error) ) {
					$errorMessage = $error->getMsg();
					$errorMessages[] = (object) [
						'attribute' => $attrName,
						'message' => $errorMessage
					];
				} else {
					$errorMessages[] = (object) [
						'attribute' => $attrName,
						'message' => 'undefined'
					];
				}
			}
		}

		return $errorMessages;
	}

	/**
	 * @desc Generates unique strings which will be placed instead of tags
	 *
	 * @param Parser $parser
	 * @return string
	 */
	protected function generateMarkerId( Parser $parser ) {
		$wikiaParserMarkerSufix = '-WIKIA-PARSER-MARKER-' . $this->getTagName() . ' - '. $this->count;
		$this->count++;
		return $parser->uniqPrefix() . $wikiaParserMarkerSufix . "-\x7f";
	}

	/**
	 * @desc Adds output which will replaced unique strings which replaced tags in the article
	 *
	 * @param String $markerId id generated by generateMarkerId()
	 * @param $output
	 */
	protected function addMarkerOutput( $markerId, $output ) {
		if( !empty( $this->wg->ArticleAsJson ) && $output instanceof WikiaResponse ) {
			/**
			 * This is tricky and I could not think about anything better than:
			 * a) encode just double-quotes, so json_decode() won't fail but then if anything else should be encoded
			 * we're doomed
			 * b) use json_encode() so we'll encode everything which should be encoded and trim the added double-quotes
			 * at the beginning since it's only a part of article content which will be wrapped with double-quotes
			 *
			 * I've chosen b) and if you think about anything which is better don't hesitate to let me know, please :)
			 */
			$this->markers[$markerId] = trim( json_encode( $output->toString() ), "\"" );
		} else {
			$this->markers[$markerId] = $output;
		}
	}

	public function getMarkers() {
		return $this->markers;
	}
}
